# RISC-V Assembly to Machine Code Translator

This project implements a simple RISC-V assembly instruction translator in C++. It reads RISC-V assembly code, parses it, and converts each instruction into its corresponding 32-bit machine code representation.

---

## Project Overview

The translator processes RISC-V assembly code and produces machine code in hexadecimal and binary formats, supporting multiple instruction types according to the RISC-V specification. The program reads input assembly code and outputs the encoded machine instructions into a file.

---

## Key Features

- **Supports Multiple Instruction Types:**  
  The project implements encoding for all common RISC-V instruction formats:
  - U-type (e.g., `lui`)
  - UJ-type (e.g., `jal`)
  - I-type (e.g., `addi`, `jalr`, `lb`)
  - SB-type (e.g., `beq`)
  - S-type (e.g., `sb`)
  - R-type (e.g., `add`, `sub`)

- **Label Resolution:**  
  The program detects labels in the assembly code and calculates relative branch offsets for jump and branch instructions.

- **Register Mapping:**  
  Registers are mapped from symbolic names (e.g., `x0`, `ra`, `sp`) to their numerical encoding using an external register file.

- **Instruction Templates:**  
  Instruction formats and opcodes are loaded from external files (`instruction_set.txt`), allowing easy modification and extension.

- **Binary and Hexadecimal Output:**  
  Outputs machine instructions in both binary and hexadecimal representations alongside the original assembly code for easy verification.

---

## How It Works

1. **Data Initialization:**  
   - Reads instruction definitions and types from `instruction_set.txt`.
   - Reads register definitions from `register.txt`.

2. **Code Parsing:**  
   - Reads assembly instructions from `riscv_code.txt`.
   - Detects labels and stores their instruction indices for offset calculation.

3. **Instruction Encoding:**  
   - For each instruction, based on its type, parses operands.
   - Encodes immediate values, register indices, and opcode fields using bit manipulation.
   - Handles specific bit placements according to RISC-V encoding rules.

4. **Output:**  
   - Writes the encoded 32-bit machine code into `machine_code.txt` in both hexadecimal and binary forms.

---


# RISC-V Assembler Tool Usage and Explanation

---

## Required Files Before Running the Program

1. **instruction_set.txt**  
   - Contains instruction names (e.g., `add`, `addi`), a numeric type ID (1~6), and a 32-bit instruction template (with default zeros for fields like rd, rs1, rs2, imm).  
   - The type ID determines which function will process the instruction.  
   - The 32-bit template encodes fixed fields like `funct7`, `funct3`, and `opcode`. During execution, fields such as `rd`, `rs1`, `rs2`, and `imm` are calculated and combined with the template via bitwise OR to form the final machine code.

Example:  
	and: funct7:0000000, rs2=0, rs1=0, funct3=111, rd=0, opcode=0110011
	Instruction: and x3,x4,x5
	Encoded fields: rs1=00100, rs2=00101, rd=00011
	Template: 00000000000000000111000000110011 (binary)
	After OR: 00000000010100100111000110110011 (final machine code)

2. **register.txt**  
- Maps register names to register numbers.  
- Includes all standard RARS registers (e.g., x0, x1, a0, t0, s0, etc.).  

Example:  
	x0 0
	x1 1

3. **riscv_code.txt**  
- User input RISC-V assembly code file to be converted into machine code.  
- Formatting rules:  
  - Labels followed by colon and a space before instruction on same line (e.g., `loop: addi x2,x5,16`) or label alone on a line without trailing spaces (e.g., `loop:`).  
  - Instructions must have a space between opcode and first operand; subsequent operands are comma-separated with no spaces (e.g., `addi x2,x5,16`, `sb x3,0(x5)`).  
  - Tabs are not allowed.  
  - All letters lowercase.  
  - Comments are not supported.

4. **machine_code.txt** (optional)  
- Output file generated by the program containing the translated machine code.

---

## Key Variables

| Variable                     | Description                                           |
|------------------------------|-----------------------------------------------------|
| `char ctemp[225]`            | Temp buffer for reading lines from files            |
| `vector<string> code`        | Stores RISC-V instructions without labels           |
| `bitset<32> mach_code`       | Temporary holder for machine code bits               |
| `map<string, unsigned long> label` | Stores labels and their instruction addresses (PC) |
| `map<string, int> instruct_type` | Maps instructions to types (1-6)                 |
| `map<string, bitset<32>> ins_template` | Stores 32-bit instruction templates             |

Instruction types mapped to IDs:

| Type ID | Instruction Type | Examples                      |
|---------|------------------|-------------------------------|
| 1       | U-type           | `lui`, `auipc`                 |
| 2       | UJ-type          | `jal`                         |
| 3       | I-type           | `jalr`, `lb`, `addi`, ...     |
| 4       | SB-type          | `beq`, `bne`, `blt`, ...      |
| 5       | S-type           | `sb`, `sh`, `sw`              |
| 6       | R-type           | `add`, `sub`, `and`, `or`     |

---

## Program Workflow

1. **`build_instruction_data()`**  
- Reads `instruction_set.txt` to populate `instruct_type` and `ins_template`.

2. **`build_register_data()`**  
- Reads `register.txt` to populate `registers`.

3. **`readcode()`**  
- Reads assembly code from `riscv_code.txt`.  
- Extracts labels and instructions, stores labels in `label` map with PC values.  
- Instructions without labels stored in `code` vector.

4. **`transfer_code()`**  
- For each instruction in `code`, splits into operator and operands.  
- Finds corresponding 32-bit template from `ins_template`.  
- Calls `type_select()` to dispatch to the correct encoding function based on instruction type:

| Encoding Function | Instruction Type | Description                                         |
|-------------------|------------------|---------------------------------------------------|
| `type_u`          | U-type           | Encodes `simm[31:12]` and `rd`                    |
| `type_uj`         | UJ-type          | Encodes `simm[20|10:1|11|19:12]` and `rd` (offset calculation: `(label.PC - current.PC) * 4`) |
| `type_i`          | I-type           | Encodes `simm[11:0]`, `rs1`, and `rd`             |
| `type_sb`         | SB-type          | Encodes `simm[12|10:5]`, `rs2`, `rs1`, `simm[4:1|11]` (offset calculation: `(label.PC - current.PC) * 4`) |
| `type_s`          | S-type           | Encodes `simm[11:5]`, `rs2`, `rs1`, `simm[4:0]`   |
| `type_r`          | R-type           | Encodes `rs2`, `rs1`, and `rd`                     |

- Each function returns a 32-bit value with the encoded fields, which is ORâ€™ed with the instruction template to produce the final machine code.

- The resulting machine code is output line-by-line to `machine_code.txt`.

---

## Bit Manipulation Details

- The assembler uses bitwise AND, OR, shifts (`&`, `|`, `<<`, `>>`) to correctly position fields in the 32-bit instruction word.

---

## Summary

This tool assembles RISC-V assembly code into machine code by:

- Parsing instructions and labels.  
- Calculating offsets for jumps and branches.  
- Encoding instructions into binary form using templates and field calculations.  
- Outputting the final machine code to a file.

---

*Refer to the source code comments for deeper insights and implementation specifics.*
